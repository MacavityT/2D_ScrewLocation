
#include "halfunc.h"
///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ (HALCON-10) Version 11.0
///////////////////////////////////////////////////////////////////////////////

#include "cpp/HalconCpp.h"

using namespace Halcon;

// Default exception handler
void CPPExpDefaultExceptionHandler(const Halcon::HException& except)
{
  throw except;
}

// Procedures
// External procedures
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message.
void disp_message (Halcon::HTuple hv_WindowHandle, Halcon::HTuple hv_String, Halcon::HTuple hv_CoordSystem,
    Halcon::HTuple hv_Row, Halcon::HTuple hv_Column, Halcon::HTuple hv_Color, Halcon::HTuple hv_Box)
{

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
  HTuple  hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1;
  HTuple  hv_C1, hv_FactorRow, hv_FactorColumn, hv_Width;
  HTuple  hv_Index, hv_Ascent, hv_Descent, hv_W, hv_H, hv_FrameHeight;
  HTuple  hv_FrameWidth, hv_R2, hv_C2, hv_DrawMode, hv_Exception;
  HTuple  hv_CurrentColor;


  // Install default exception handler
  HException::InstallHHandler(&CPPExpDefaultExceptionHandler);

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //Box: If set to 'true', the text is written within a white box.
  //
  //prepare window
  get_rgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  get_part(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  get_window_extents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  set_part(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //default settings
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_Color==HTuple()))
  {
    hv_Color = "";
  }
  //
  hv_String = ((""+hv_String)+"").Split("\n");
  //
  //Estimate extentions of text depending on font size.
  get_font_extents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth,
      &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //transform image to window coordinates
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //display text box depending on text size
  if (0 != (hv_Box==HTuple("true")))
  {
    //calculate box extents
    hv_String = (" "+hv_String)+" ";
    hv_Width = HTuple();
    HTuple end_val57 = (hv_String.Num())-1;
    HTuple step_val57 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val57, step_val57); hv_Index += step_val57)
    {
      get_string_extents(hv_WindowHandle, hv_String.Select(hv_Index), &hv_Ascent,
          &hv_Descent, &hv_W, &hv_H);
      hv_Width = hv_Width.Concat(hv_W);
    }
    hv_FrameHeight = hv_MaxHeight*(hv_String.Num());
    hv_FrameWidth = (HTuple(0).Concat(hv_Width)).Max();
    hv_R2 = hv_R1+hv_FrameHeight;
    hv_C2 = hv_C1+hv_FrameWidth;
    //display rectangles
    get_draw(hv_WindowHandle, &hv_DrawMode);
    set_draw(hv_WindowHandle, "fill");
    set_color(hv_WindowHandle, "light gray");
    disp_rectangle1(hv_WindowHandle, hv_R1+3, hv_C1+3, hv_R2+3, hv_C2+3);
    set_color(hv_WindowHandle, "white");
    disp_rectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
    set_draw(hv_WindowHandle, hv_DrawMode);
  }
  else if (0 != (hv_Box!=HTuple("false")))
  {
    hv_Exception = "Wrong value of control parameter Box";
    throw HException(hv_Exception);
  }
  //Write text.
  HTuple end_val78 = (hv_String.Num())-1;
  HTuple step_val78 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val78, step_val78); hv_Index += step_val78)
  {
    hv_CurrentColor = hv_Color.Select(hv_Index%(hv_Color.Num()));
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).And(hv_CurrentColor!=HTuple("auto"))))
    {
      set_color(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      set_rgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    set_tposition(hv_WindowHandle, hv_Row, hv_C1);
    write_string(hv_WindowHandle, hv_String.Select(hv_Index));
  }
  //reset changed window settings
  set_rgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  set_part(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

// Chapter: File
// Short Description: Get all image files under the given path
void list_image_files (Halcon::HTuple hv_ImageDirectory, Halcon::HTuple hv_Extensions,
    Halcon::HTuple hv_Options, Halcon::HTuple *hv_ImageFiles)
{

  // Local control variables
  HTuple  hv_HalconImages, hv_OS, hv_Directories;
  HTuple  hv_Index, hv_FileExists, hv_AllFiles, hv_i, hv_Selection;

  //This procedure returns all files in a given directory
  //with one of the suffixes specified in Extensions.
  //
  //input parameters:
  //ImageDirectory: as the name says
  //   If a tuple of directories is given, only the images in the first
  //   existing directory are returned.
  //   If a local directory is not found, the directory is searched
  //   under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,
  //   %HALCONROOT%/images is used instead.
  //Extensions: A string tuple containing the extensions to be found
  //   e.g. ['png','tif',jpg'] or others
  //If Extensions is set to 'default' or the empty string '',
  //   all image suffixes supported by HALCON are used.
  //Options: as in the operator list_files, except that the 'files'
  //   option is always used. Note that the 'directories' option
  //   has no effect but increases runtime, because only files are
  //   returned.
  //
  //output parameter:
  //ImageFiles: A tuple of all found image file names
  //
  if (0 != (HTuple(HTuple(hv_Extensions==HTuple()).Or(hv_Extensions==HTuple(""))).Or(hv_Extensions==HTuple("default"))))
  {
    hv_Extensions.Reset();
    hv_Extensions[0] = "ima";
    hv_Extensions[1] = "tif";
    hv_Extensions[2] = "tiff";
    hv_Extensions[3] = "gif";
    hv_Extensions[4] = "bmp";
    hv_Extensions[5] = "jpg";
    hv_Extensions[6] = "jpeg";
    hv_Extensions[7] = "jp2";
    hv_Extensions[8] = "jxr";
    hv_Extensions[9] = "png";
    hv_Extensions[10] = "pcx";
    hv_Extensions[11] = "ras";
    hv_Extensions[12] = "xwd";
    hv_Extensions[13] = "pbm";
    hv_Extensions[14] = "pnm";
    hv_Extensions[15] = "pgm";
    hv_Extensions[16] = "ppm";

  }
  if (0 != (hv_ImageDirectory==HTuple("")))
  {
    hv_ImageDirectory = ".";
  }
  get_system("image_dir", &hv_HalconImages);
  get_system("operating_system", &hv_OS);
  if (0 != ((hv_OS.Substr(0,2))==HTuple("Win")))
  {
    hv_HalconImages = hv_HalconImages.Split(";");
  }
  else
  {
    hv_HalconImages = hv_HalconImages.Split(":");
  }
  hv_Directories.Reset();
  hv_Directories.Append(hv_ImageDirectory);
  hv_Directories.Append((hv_HalconImages+"/")+hv_ImageDirectory);
  (*hv_ImageFiles) = HTuple();
  HTuple end_val38 = (hv_Directories.Num())-1;
  HTuple step_val38 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val38, step_val38); hv_Index += step_val38)
  {
    file_exists(hv_Directories.Select(hv_Index), &hv_FileExists);
    if (0 != hv_FileExists)
    {
      list_files(hv_Directories.Select(hv_Index), HTuple("files").Concat(hv_Options),
          &hv_AllFiles);
      (*hv_ImageFiles) = HTuple();
      HTuple end_val43 = (hv_Extensions.Num())-1;
      HTuple step_val43 = 1;
      for (hv_i=0; hv_i.Continue(end_val43, step_val43); hv_i += step_val43)
      {
        tuple_regexp_select(hv_AllFiles, ((".*"+(hv_Extensions.Select(hv_i)))+"$").Concat("ignore_case"),
            &hv_Selection);
        (*hv_ImageFiles) = (*hv_ImageFiles).Concat(hv_Selection);
      }
      tuple_regexp_replace((*hv_ImageFiles), (HTuple("\\\\").Append("replace_all")),
          "/", &(*hv_ImageFiles));
      tuple_regexp_replace((*hv_ImageFiles), (HTuple("//").Append("replace_all")),
          "/", &(*hv_ImageFiles));
      return;
    }
  }
  return;
}

// Chapter: Graphics / Text
// Short Description: Set font independent of OS
void set_display_font (Halcon::HTuple hv_WindowHandle, Halcon::HTuple hv_Size, Halcon::HTuple hv_Font,
    Halcon::HTuple hv_Bold, Halcon::HTuple hv_Slant)
{

  // Local control variables
  HTuple  hv_OS, hv_PreferenceValue, hv_Exception;
  HTuple  hv_BoldString, hv_SlantString, hv_AllowedFontSizes;
  HTuple  hv_Distances, hv_Indices, hv_Fonts, hv_FontSelRegexp;
  HTuple  hv_FontsCourier;


  // Install default exception handler
  HException::InstallHHandler(&CPPExpDefaultExceptionHandler);

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //It is assumed that following fonts are installed on the system:
  //Windows: Courier New, Arial Times New Roman
  //Mac OS X: CourierNewPS, Arial, TimesNewRomanPS
  //Linux: courier, helvetica, times
  //Because fonts are displayed smaller on Linux than on Windows,
  //a scaling factor of 1.25 is used the get comparable results.
  //For Linux, only a limited number of font sizes is supported,
  //to get comparable results, it is recommended to use one of the
  //following sizes: 9, 11, 14, 16, 20, 27
  //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
  //
  //Input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  get_system("operating_system", &hv_OS);
  // dev_get_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  if (0 != (HTuple(hv_Size==HTuple()).Or(hv_Size==-1)))
  {
    hv_Size = 16;
  }
  if (0 != ((hv_OS.Substr(0,2))==HTuple("Win")))
  {
    //Set font on Windows systems
    if (0 != (HTuple(HTuple(hv_Font==HTuple("mono")).Or(hv_Font==HTuple("Courier"))).Or(hv_Font==HTuple("courier"))))
    {
      hv_Font = "Courier New";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "Arial";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "Times New Roman";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = 1;
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_Slant = 1;
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HException(hv_Exception);
    }
    try
    {
      set_font(hv_WindowHandle, ((((((("-"+hv_Font)+"-")+hv_Size)+"-*-")+hv_Slant)+"-*-*-")+hv_Bold)+"-");
    }
    // catch (Exception)
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else if (0 != ((hv_OS.Substr(0,2))==HTuple("Dar")))
  {
    //Set font on Mac OS X systems
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_BoldString = "Bold";
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_BoldString = "";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_SlantString = "Italic";
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_SlantString = "";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HException(hv_Exception);
    }
    if (0 != (HTuple(HTuple(hv_Font==HTuple("mono")).Or(hv_Font==HTuple("Courier"))).Or(hv_Font==HTuple("courier"))))
    {
      hv_Font = "CourierNewPS";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "Arial";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "TimesNewRomanPS";
    }
    if (0 != (HTuple(hv_Bold==HTuple("true")).Or(hv_Slant==HTuple("true"))))
    {
      hv_Font = ((hv_Font+"-")+hv_BoldString)+hv_SlantString;
    }
    hv_Font += HTuple("MT");
    try
    {
      set_font(hv_WindowHandle, (hv_Font+"-")+hv_Size);
    }
    // catch (Exception)
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else
  {
    //Set font for UNIX systems
    hv_Size = hv_Size*1.25;
    hv_AllowedFontSizes.Reset();
    hv_AllowedFontSizes[0] = 11;
    hv_AllowedFontSizes[1] = 14;
    hv_AllowedFontSizes[2] = 17;
    hv_AllowedFontSizes[3] = 20;
    hv_AllowedFontSizes[4] = 25;
    hv_AllowedFontSizes[5] = 34;
    if (0 != ((hv_AllowedFontSizes.Find(hv_Size))==-1))
    {
      hv_Distances = (hv_AllowedFontSizes-hv_Size).Abs();
      tuple_sort_index(hv_Distances, &hv_Indices);
      hv_Size = hv_AllowedFontSizes.Select(hv_Indices.Select(0));
    }
    if (0 != (HTuple(hv_Font==HTuple("mono")).Or(hv_Font==HTuple("Courier"))))
    {
      hv_Font = "courier";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "helvetica";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "times";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = "bold";
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = "medium";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      if (0 != (hv_Font==HTuple("times")))
      {
        hv_Slant = "i";
      }
      else
      {
        hv_Slant = "o";
      }
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = "r";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HException(hv_Exception);
    }
    try
    {
      set_font(hv_WindowHandle, ((((((("-adobe-"+hv_Font)+"-")+hv_Bold)+"-")+hv_Slant)+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
    }
    // catch (Exception)
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      if (0 != (HTuple((hv_OS.Substr(0,4))==HTuple("Linux")).And(hv_Font==HTuple("courier"))))
      {
        query_font(hv_WindowHandle, &hv_Fonts);
        hv_FontSelRegexp = (("^-[^-]*-[^-]*[Cc]ourier[^-]*-"+hv_Bold)+"-")+hv_Slant;
        hv_FontsCourier = (hv_Fonts.RegexpSelect(hv_FontSelRegexp)).RegexpMatch(hv_FontSelRegexp);
        if (0 != ((hv_FontsCourier.Num())==0))
        {
          hv_Exception = "Wrong font name";
          //throw (Exception)
        }
        else
        {
          try
          {
            set_font(hv_WindowHandle, (((hv_FontsCourier.Select(0))+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
          }
          // catch (Exception)
          catch (HException &HDevExpDefaultException)
          {
            HDevExpDefaultException.ToHTuple(&hv_Exception);
            //throw (Exception)
          }
        }
      }
      //throw (Exception)
    }
  }
  // dev_set_preferences(...); only in hdevelop
  return;
}







